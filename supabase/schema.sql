-- Run this in Supabase SQL Editor

create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null unique,
  username text not null,
  avatar_url text,
  bio text,
  preferred_player text not null default 'spotify',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.profiles add column if not exists avatar_url text;
alter table public.profiles add column if not exists bio text;
alter table public.profiles add column if not exists preferred_player text not null default 'spotify';

alter table public.profiles enable row level security;

drop policy if exists "profiles_select_own" on public.profiles;
create policy "profiles_select_own"
on public.profiles
for select
to authenticated
using (auth.uid() = id);

drop policy if exists "profiles_insert_own" on public.profiles;
create policy "profiles_insert_own"
on public.profiles
for insert
to authenticated
with check (auth.uid() = id);

drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own"
on public.profiles
for update
to authenticated
using (auth.uid() = id)
with check (auth.uid() = id);

alter table public.profiles
  alter column username set not null;

do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'profiles_username_length_chk'
  ) then
    alter table public.profiles
      add constraint profiles_username_length_chk
      check (char_length(trim(username)) between 3 and 40);
  end if;

  if not exists (
    select 1 from pg_constraint
    where conname = 'profiles_bio_length_chk'
  ) then
    alter table public.profiles
      add constraint profiles_bio_length_chk
      check (bio is null or char_length(bio) <= 180);
  end if;

  if not exists (
    select 1 from pg_constraint
    where conname = 'profiles_preferred_player_chk'
  ) then
    alter table public.profiles
      add constraint profiles_preferred_player_chk
      check (preferred_player in ('spotify', 'deezer', 'youtube_music'));
  end if;
end $$;

-- Friend requests and social comparison
create table if not exists public.friend_requests (
  id bigint generated by default as identity primary key,
  requester_id uuid not null references auth.users(id) on delete cascade,
  recipient_id uuid not null references auth.users(id) on delete cascade,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'rejected')),
  created_at timestamptz not null default now(),
  responded_at timestamptz
);

create unique index if not exists idx_friend_requests_pair_unique
on public.friend_requests(requester_id, recipient_id);

create index if not exists idx_friend_requests_recipient_status
on public.friend_requests(recipient_id, status);

alter table public.friend_requests enable row level security;

drop policy if exists "friend_requests_select_related" on public.friend_requests;
create policy "friend_requests_select_related"
on public.friend_requests
for select
to authenticated
using (auth.uid() = requester_id or auth.uid() = recipient_id);

drop policy if exists "friend_requests_insert_self" on public.friend_requests;
create policy "friend_requests_insert_self"
on public.friend_requests
for insert
to authenticated
with check (auth.uid() = requester_id and requester_id <> recipient_id);

drop policy if exists "friend_requests_update_recipient" on public.friend_requests;
create policy "friend_requests_update_recipient"
on public.friend_requests
for update
to authenticated
using (auth.uid() = recipient_id and status = 'pending')
with check (auth.uid() = recipient_id and status in ('accepted', 'rejected'));

create or replace function public.create_friend_request_by_username(target_username text)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  me uuid := auth.uid();
  target uuid;
  existing_status text;
begin
  if me is null then
    raise exception 'not authenticated';
  end if;

  select id into target
  from public.profiles
  where lower(username) = lower(trim(target_username))
     or lower(email) = lower(trim(target_username))
  limit 1;

  if target is null then
    raise exception 'user not found';
  end if;

  if target = me then
    raise exception 'cannot add yourself';
  end if;

  select status into existing_status
  from public.friend_requests
  where (requester_id = me and recipient_id = target)
     or (requester_id = target and recipient_id = me)
  order by id desc
  limit 1;

  if existing_status = 'accepted' then
    return 'already friends';
  end if;

  if existing_status = 'pending' then
    update public.friend_requests
      set status = 'accepted',
          responded_at = now()
    where requester_id = target
      and recipient_id = me
      and status = 'pending';
    return 'request accepted';
  end if;

  insert into public.friend_requests (requester_id, recipient_id, status)
  values (me, target, 'pending')
  on conflict (requester_id, recipient_id) do update
    set status = 'pending',
        responded_at = null;

  return 'request sent';
end;
$$;

revoke all on function public.create_friend_request_by_username(text) from public;
grant execute on function public.create_friend_request_by_username(text) to authenticated;

-- Resolve login identifier (email or username) to email for auth flow
create or replace function public.get_login_email(login_identifier text)
returns text
language sql
security definer
set search_path = public
as $$
  select p.email
  from public.profiles p
  where lower(p.email) = lower(trim(login_identifier))
     or lower(p.username) = lower(trim(login_identifier))
  order by case when lower(p.email) = lower(trim(login_identifier)) then 0 else 1 end
  limit 1;
$$;

revoke all on function public.get_login_email(text) from public;
grant execute on function public.get_login_email(text) to anon, authenticated;

create or replace function public.respond_friend_request(req_id bigint, accept_request boolean)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  update public.friend_requests
  set status = case when accept_request then 'accepted' else 'rejected' end,
      responded_at = now()
  where id = req_id
    and recipient_id = auth.uid()
    and status = 'pending';

  if not found then
    raise exception 'request not found';
  end if;
end;
$$;

revoke all on function public.respond_friend_request(bigint, boolean) from public;
grant execute on function public.respond_friend_request(bigint, boolean) to authenticated;

drop function if exists public.get_my_friend_requests();
create or replace function public.get_my_friend_requests()
returns table (
  request_id bigint,
  direction text,
  username text,
  avatar_url text,
  status text,
  created_at timestamptz
)
language sql
security definer
set search_path = public
as $$
  select
    fr.id as request_id,
    case when fr.recipient_id = auth.uid() then 'incoming' else 'outgoing' end as direction,
    coalesce(p.username, 'unknown') as username,
    p.avatar_url,
    fr.status,
    fr.created_at
  from public.friend_requests fr
  left join public.profiles p
    on p.id = case when fr.recipient_id = auth.uid() then fr.requester_id else fr.recipient_id end
  where fr.requester_id = auth.uid() or fr.recipient_id = auth.uid()
  order by fr.created_at desc;
$$;

revoke all on function public.get_my_friend_requests() from public;
grant execute on function public.get_my_friend_requests() to authenticated;

drop function if exists public.get_my_friends_with_stats();
create or replace function public.get_my_friends_with_stats()
returns table (
  friend_id uuid,
  username text,
  avatar_url text,
  games integer,
  best_wpm integer,
  avg_wpm integer,
  avg_acc integer
)
language sql
security definer
set search_path = public
as $$
  with friends as (
    select case when fr.requester_id = auth.uid() then fr.recipient_id else fr.requester_id end as friend_id
    from public.friend_requests fr
    where fr.status = 'accepted'
      and (fr.requester_id = auth.uid() or fr.recipient_id = auth.uid())
  )
  select
    f.friend_id,
    coalesce(p.username, 'unknown') as username,
    p.avatar_url,
    count(gr.id)::int as games,
    coalesce(max(gr.wpm), 0)::int as best_wpm,
    coalesce(round(avg(gr.wpm)), 0)::int as avg_wpm,
    coalesce(round(avg(gr.accuracy)), 0)::int as avg_acc
  from friends f
  left join public.profiles p on p.id = f.friend_id
  left join public.game_results gr on gr.user_id = f.friend_id
  group by f.friend_id, p.username, p.avatar_url
  order by avg_wpm desc, games desc, username asc;
$$;

revoke all on function public.get_my_friends_with_stats() from public;
grant execute on function public.get_my_friends_with_stats() to authenticated;

create or replace function public.set_profiles_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row
execute function public.set_profiles_updated_at();

-- Optional helper: create profile automatically on signup
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, email, username)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'username', split_part(new.email, '@', 1))
  )
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row
execute function public.handle_new_user();

-- Account deletion for logged users
create or replace function public.delete_my_account()
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  delete from auth.users where id = auth.uid();
end;
$$;

revoke all on function public.delete_my_account() from public;
grant execute on function public.delete_my_account() to authenticated;

-- Game results
create table if not exists public.game_results (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  song_title text,
  artist text,
  mode text not null default 'normal' check (mode in ('normal', 'cloze', 'rhythm')),
  wpm integer not null default 0,
  accuracy integer not null default 0,
  words_correct integer not null default 0,
  words_wrong integer not null default 0,
  total_chars integer not null default 0,
  incorrect_chars integer not null default 0,
  extra_chars integer not null default 0,
  duration_seconds integer not null default 0,
  created_at timestamptz not null default now()
);

create index if not exists idx_game_results_user_created_at
on public.game_results(user_id, created_at desc);

alter table public.game_results enable row level security;

drop policy if exists "game_results_select_own" on public.game_results;
create policy "game_results_select_own"
on public.game_results
for select
to authenticated
using (auth.uid() = user_id);

drop policy if exists "game_results_insert_own" on public.game_results;
create policy "game_results_insert_own"
on public.game_results
for insert
to authenticated
with check (auth.uid() = user_id);

drop policy if exists "game_results_delete_own" on public.game_results;
create policy "game_results_delete_own"
on public.game_results
for delete
to authenticated
using (auth.uid() = user_id);

do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'game_results_accuracy_chk'
  ) then
    alter table public.game_results
      add constraint game_results_accuracy_chk
      check (accuracy between 0 and 100);
  end if;

  if not exists (
    select 1 from pg_constraint
    where conname = 'game_results_non_negative_chk'
  ) then
    alter table public.game_results
      add constraint game_results_non_negative_chk
      check (
        wpm >= 0 and
        words_correct >= 0 and
        words_wrong >= 0 and
        total_chars >= 0 and
        incorrect_chars >= 0 and
        extra_chars >= 0 and
        duration_seconds >= 0
      );
  end if;
end $$;

-- Favorites playlist
create table if not exists public.user_favorites (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  song_title text not null,
  artist text not null,
  source_type text not null default 'catalog' check (source_type in ('catalog', 'custom')),
  custom_lyrics text,
  custom_translation text,
  created_at timestamptz not null default now(),
  unique(user_id, song_title, artist)
);

alter table public.user_favorites add column if not exists source_type text not null default 'catalog';
alter table public.user_favorites add column if not exists custom_lyrics text;
alter table public.user_favorites add column if not exists custom_translation text;

do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'user_favorites_source_type_chk'
  ) then
    alter table public.user_favorites
      add constraint user_favorites_source_type_chk
      check (source_type in ('catalog', 'custom'));
  end if;

  if not exists (
    select 1 from pg_constraint
    where conname = 'user_favorites_custom_lengths_chk'
  ) then
    alter table public.user_favorites
      add constraint user_favorites_custom_lengths_chk
      check (
        (custom_lyrics is null or char_length(custom_lyrics) <= 4000)
        and (custom_translation is null or char_length(custom_translation) <= 4000)
        and (coalesce(char_length(custom_lyrics), 0) + coalesce(char_length(custom_translation), 0) <= 6500)
      );
  end if;
end $$;

create index if not exists idx_user_favorites_user_created
on public.user_favorites(user_id, created_at desc);

alter table public.user_favorites enable row level security;

drop policy if exists "user_favorites_select_own" on public.user_favorites;
create policy "user_favorites_select_own"
on public.user_favorites
for select
to authenticated
using (auth.uid() = user_id);

drop policy if exists "user_favorites_insert_own" on public.user_favorites;
create policy "user_favorites_insert_own"
on public.user_favorites
for insert
to authenticated
with check (auth.uid() = user_id);

drop policy if exists "user_favorites_delete_own" on public.user_favorites;
create policy "user_favorites_delete_own"
on public.user_favorites
for delete
to authenticated
using (auth.uid() = user_id);

grant select, insert, delete on table public.user_favorites to authenticated;
grant usage, select on sequence public.user_favorites_id_seq to authenticated;

-- Avatar storage bucket (public read, owner write/delete)
insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

drop policy if exists "avatars_public_read" on storage.objects;
create policy "avatars_public_read"
on storage.objects
for select
to public
using (bucket_id = 'avatars');

drop policy if exists "avatars_insert_own" on storage.objects;
create policy "avatars_insert_own"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
);

drop policy if exists "avatars_update_own" on storage.objects;
create policy "avatars_update_own"
on storage.objects
for update
to authenticated
using (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
)
with check (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
);

drop policy if exists "avatars_delete_own" on storage.objects;
create policy "avatars_delete_own"
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
);

-- Shared result cards (score links)
create table if not exists public.shared_results (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  song_title text,
  artist text,
  mode text not null default 'normal' check (mode in ('normal', 'cloze', 'rhythm')),
  wpm integer not null default 0,
  accuracy integer not null default 0 check (accuracy between 0 and 100),
  raw integer not null default 0,
  consistency integer not null default 0 check (consistency between 0 and 100),
  duration_seconds integer not null default 0,
  created_at timestamptz not null default now()
);

create index if not exists idx_shared_results_created_at
on public.shared_results(created_at desc);

create index if not exists idx_shared_results_user_created_at
on public.shared_results(user_id, created_at desc);

alter table public.shared_results enable row level security;

drop policy if exists "shared_results_select_auth" on public.shared_results;
create policy "shared_results_select_auth"
on public.shared_results
for select
to authenticated
using (true);

drop policy if exists "shared_results_insert_own" on public.shared_results;
create policy "shared_results_insert_own"
on public.shared_results
for insert
to authenticated
with check (auth.uid() = user_id);

drop function if exists public.create_shared_result(text, text, text, integer, integer, integer, integer, integer);
create or replace function public.create_shared_result(
  p_song_title text,
  p_artist text,
  p_mode text,
  p_wpm integer,
  p_accuracy integer,
  p_raw integer,
  p_consistency integer,
  p_duration_seconds integer
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_id uuid;
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  insert into public.shared_results (
    user_id,
    song_title,
    artist,
    mode,
    wpm,
    accuracy,
    raw,
    consistency,
    duration_seconds
  ) values (
    auth.uid(),
    p_song_title,
    p_artist,
    coalesce(p_mode, 'normal'),
    coalesce(p_wpm, 0),
    coalesce(p_accuracy, 0),
    coalesce(p_raw, 0),
    coalesce(p_consistency, 0),
    coalesce(p_duration_seconds, 0)
  )
  returning id into v_id;

  return v_id;
end;
$$;

revoke all on function public.create_shared_result(text, text, text, integer, integer, integer, integer, integer) from public;
grant execute on function public.create_shared_result(text, text, text, integer, integer, integer, integer, integer) to authenticated;

drop function if exists public.get_shared_result(uuid);
create or replace function public.get_shared_result(p_share_id uuid)
returns table (
  id uuid,
  owner_id uuid,
  owner_username text,
  owner_avatar_url text,
  song_title text,
  artist text,
  mode text,
  wpm integer,
  accuracy integer,
  raw integer,
  consistency integer,
  duration_seconds integer,
  created_at timestamptz
)
language sql
security definer
set search_path = public
as $$
  select
    sr.id,
    sr.user_id as owner_id,
    coalesce(p.username, 'unknown') as owner_username,
    p.avatar_url as owner_avatar_url,
    sr.song_title,
    sr.artist,
    sr.mode,
    sr.wpm,
    sr.accuracy,
    sr.raw,
    sr.consistency,
    sr.duration_seconds,
    sr.created_at
  from public.shared_results sr
  left join public.profiles p on p.id = sr.user_id
  where sr.id = p_share_id
  limit 1;
$$;

revoke all on function public.get_shared_result(uuid) from public;
grant execute on function public.get_shared_result(uuid) to anon, authenticated;

-- Duel mode (room + invite + race)
create table if not exists public.duel_rooms (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  song_title text not null,
  artist text,
  lyrics text not null,
  translation text,
  status text not null default 'waiting' check (status in ('waiting', 'countdown', 'active', 'finished', 'canceled')),
  countdown_seconds integer not null default 5 check (countdown_seconds between 3 and 15),
  started_at timestamptz,
  finished_at timestamptz,
  created_at timestamptz not null default now()
);

create table if not exists public.duel_room_members (
  room_id uuid not null references public.duel_rooms(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  joined_at timestamptz not null default now(),
  primary key (room_id, user_id)
);

create table if not exists public.duel_room_invites (
  id bigint generated by default as identity primary key,
  room_id uuid not null references public.duel_rooms(id) on delete cascade,
  inviter_id uuid not null references auth.users(id) on delete cascade,
  invitee_id uuid not null references auth.users(id) on delete cascade,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'rejected', 'canceled')),
  created_at timestamptz not null default now(),
  responded_at timestamptz
);

create unique index if not exists idx_duel_invites_room_invitee
on public.duel_room_invites(room_id, invitee_id);

create index if not exists idx_duel_invites_invitee_status
on public.duel_room_invites(invitee_id, status, created_at desc);

create table if not exists public.duel_progress (
  room_id uuid not null references public.duel_rooms(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  typed_words integer not null default 0 check (typed_words >= 0),
  typed_chars integer not null default 0 check (typed_chars >= 0),
  wpm integer not null default 0 check (wpm >= 0),
  accuracy integer not null default 0 check (accuracy between 0 and 100),
  is_finished boolean not null default false,
  finished_at timestamptz,
  updated_at timestamptz not null default now(),
  primary key (room_id, user_id)
);

alter table public.duel_rooms enable row level security;
alter table public.duel_room_members enable row level security;
alter table public.duel_room_invites enable row level security;
alter table public.duel_progress enable row level security;

drop policy if exists "duel_rooms_select_members" on public.duel_rooms;
create policy "duel_rooms_select_members"
on public.duel_rooms
for select
to authenticated
using (
  owner_id = auth.uid()
  or exists (
    select 1
    from public.duel_room_members m
    where m.room_id = id
      and m.user_id = auth.uid()
  )
);

drop policy if exists "duel_rooms_insert_owner" on public.duel_rooms;
create policy "duel_rooms_insert_owner"
on public.duel_rooms
for insert
to authenticated
with check (owner_id = auth.uid());

drop policy if exists "duel_rooms_update_owner" on public.duel_rooms;
create policy "duel_rooms_update_owner"
on public.duel_rooms
for update
to authenticated
using (owner_id = auth.uid())
with check (owner_id = auth.uid());

drop policy if exists "duel_members_select_related" on public.duel_room_members;
create policy "duel_members_select_related"
on public.duel_room_members
for select
to authenticated
using (
  user_id = auth.uid()
  or exists (
    select 1
    from public.duel_room_members me
    where me.room_id = room_id
      and me.user_id = auth.uid()
  )
);

drop policy if exists "duel_members_insert_self" on public.duel_room_members;
create policy "duel_members_insert_self"
on public.duel_room_members
for insert
to authenticated
with check (user_id = auth.uid());

drop policy if exists "duel_members_delete_self" on public.duel_room_members;
create policy "duel_members_delete_self"
on public.duel_room_members
for delete
to authenticated
using (user_id = auth.uid());

drop policy if exists "duel_invites_select_related" on public.duel_room_invites;
create policy "duel_invites_select_related"
on public.duel_room_invites
for select
to authenticated
using (inviter_id = auth.uid() or invitee_id = auth.uid());

drop policy if exists "duel_invites_insert_inviter" on public.duel_room_invites;
create policy "duel_invites_insert_inviter"
on public.duel_room_invites
for insert
to authenticated
with check (inviter_id = auth.uid());

drop policy if exists "duel_invites_update_related" on public.duel_room_invites;
create policy "duel_invites_update_related"
on public.duel_room_invites
for update
to authenticated
using (inviter_id = auth.uid() or invitee_id = auth.uid())
with check (inviter_id = auth.uid() or invitee_id = auth.uid());

drop policy if exists "duel_progress_select_related" on public.duel_progress;
create policy "duel_progress_select_related"
on public.duel_progress
for select
to authenticated
using (
  user_id = auth.uid()
  or exists (
    select 1
    from public.duel_room_members me
    where me.room_id = room_id
      and me.user_id = auth.uid()
  )
);

drop policy if exists "duel_progress_insert_self_member" on public.duel_progress;
create policy "duel_progress_insert_self_member"
on public.duel_progress
for insert
to authenticated
with check (
  user_id = auth.uid()
  and exists (
    select 1
    from public.duel_room_members me
    where me.room_id = room_id
      and me.user_id = auth.uid()
  )
);

drop policy if exists "duel_progress_update_self_member" on public.duel_progress;
create policy "duel_progress_update_self_member"
on public.duel_progress
for update
to authenticated
using (
  user_id = auth.uid()
  and exists (
    select 1
    from public.duel_room_members me
    where me.room_id = room_id
      and me.user_id = auth.uid()
  )
)
with check (
  user_id = auth.uid()
  and exists (
    select 1
    from public.duel_room_members me
    where me.room_id = room_id
      and me.user_id = auth.uid()
  )
);

create or replace function public.create_duel_room(
  p_song_title text,
  p_artist text,
  p_lyrics text,
  p_translation text default null
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_id uuid;
  v_title text := trim(coalesce(p_song_title, ''));
  v_artist text := trim(coalesce(p_artist, ''));
  v_lyrics text := trim(coalesce(p_lyrics, ''));
  v_translation text := trim(coalesce(p_translation, ''));
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  if v_title = '' then
    raise exception 'song title required';
  end if;

  if v_lyrics = '' then
    raise exception 'lyrics required';
  end if;

  if char_length(v_lyrics) > 4000 then
    raise exception 'lyrics too long';
  end if;

  if char_length(v_translation) > 4000 then
    raise exception 'translation too long';
  end if;

  if char_length(v_lyrics) + char_length(v_translation) > 6500 then
    raise exception 'lyrics + translation too long';
  end if;

  insert into public.duel_rooms (owner_id, song_title, artist, lyrics, translation)
  values (auth.uid(), v_title, nullif(v_artist, ''), v_lyrics, nullif(v_translation, ''))
  returning id into v_room_id;

  insert into public.duel_room_members (room_id, user_id)
  values (v_room_id, auth.uid())
  on conflict (room_id, user_id) do nothing;

  return v_room_id;
end;
$$;

revoke all on function public.create_duel_room(text, text, text, text) from public;
grant execute on function public.create_duel_room(text, text, text, text) to authenticated;

create or replace function public.join_duel_room(p_room_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room record;
  v_member_count integer;
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  select id, status into v_room
  from public.duel_rooms
  where id = p_room_id
  limit 1;

  if v_room.id is null then
    raise exception 'room not found';
  end if;

  if v_room.status not in ('waiting', 'countdown', 'active') then
    raise exception 'room unavailable';
  end if;

  select count(*)::int into v_member_count
  from public.duel_room_members
  where room_id = p_room_id;

  if v_member_count >= 2 then
    raise exception 'room full';
  end if;

  insert into public.duel_room_members (room_id, user_id)
  values (p_room_id, auth.uid())
  on conflict (room_id, user_id) do nothing;
end;
$$;

revoke all on function public.join_duel_room(uuid) from public;
grant execute on function public.join_duel_room(uuid) to authenticated;

create or replace function public.invite_duel_player(
  p_room_id uuid,
  p_target_identifier text
)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_owner uuid;
  v_target uuid;
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  select owner_id into v_room_owner
  from public.duel_rooms
  where id = p_room_id
  limit 1;

  if v_room_owner is null then
    raise exception 'room not found';
  end if;

  if v_room_owner <> auth.uid() then
    raise exception 'only owner can invite';
  end if;

  select p.id into v_target
  from public.profiles p
  where lower(p.username) = lower(trim(p_target_identifier))
     or lower(p.email) = lower(trim(p_target_identifier))
  limit 1;

  if v_target is null then
    raise exception 'user not found';
  end if;

  if v_target = auth.uid() then
    raise exception 'cannot invite yourself';
  end if;

  insert into public.duel_room_invites (room_id, inviter_id, invitee_id, status)
  values (p_room_id, auth.uid(), v_target, 'pending')
  on conflict (room_id, invitee_id) do update
    set status = 'pending',
        responded_at = null,
        inviter_id = excluded.inviter_id,
        created_at = now();

  return 'invite sent';
end;
$$;

revoke all on function public.invite_duel_player(uuid, text) from public;
grant execute on function public.invite_duel_player(uuid, text) to authenticated;

create or replace function public.respond_duel_invite(
  p_invite_id bigint,
  p_accept boolean
)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_id uuid;
  v_member_count integer;
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  update public.duel_room_invites dri
  set status = case when p_accept then 'accepted' else 'rejected' end,
      responded_at = now()
  where dri.id = p_invite_id
    and dri.invitee_id = auth.uid()
    and dri.status = 'pending'
  returning dri.room_id into v_room_id;

  if v_room_id is null then
    raise exception 'invite not found';
  end if;

  if p_accept then
    select count(*)::int into v_member_count
    from public.duel_room_members
    where room_id = v_room_id;

    if v_member_count >= 2 then
      raise exception 'room full';
    end if;

    insert into public.duel_room_members (room_id, user_id)
    values (v_room_id, auth.uid())
    on conflict (room_id, user_id) do nothing;
  end if;

  return v_room_id;
end;
$$;

revoke all on function public.respond_duel_invite(bigint, boolean) from public;
grant execute on function public.respond_duel_invite(bigint, boolean) to authenticated;

create or replace function public.start_duel_room(
  p_room_id uuid,
  p_countdown_seconds integer default 5
)
returns timestamptz
language plpgsql
security definer
set search_path = public
as $$
declare
  v_owner uuid;
  v_member_count integer;
  v_cd integer := greatest(3, least(coalesce(p_countdown_seconds, 5), 15));
  v_start timestamptz := now() + make_interval(secs => v_cd);
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  select owner_id into v_owner
  from public.duel_rooms
  where id = p_room_id
  limit 1;

  if v_owner is null then
    raise exception 'room not found';
  end if;

  if v_owner <> auth.uid() then
    raise exception 'only owner can start';
  end if;

  select count(*)::int into v_member_count
  from public.duel_room_members
  where room_id = p_room_id;

  if v_member_count < 2 then
    raise exception 'at least 2 players required';
  end if;

  delete from public.duel_progress where room_id = p_room_id;

  update public.duel_rooms
  set status = 'countdown',
      countdown_seconds = v_cd,
      started_at = v_start,
      finished_at = null
  where id = p_room_id;

  return v_start;
end;
$$;

revoke all on function public.start_duel_room(uuid, integer) from public;
grant execute on function public.start_duel_room(uuid, integer) to authenticated;

create or replace function public.leave_duel_room(p_room_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_owner uuid;
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  delete from public.duel_room_members
  where room_id = p_room_id
    and user_id = auth.uid();

  delete from public.duel_progress
  where room_id = p_room_id
    and user_id = auth.uid();

  select owner_id into v_owner
  from public.duel_rooms
  where id = p_room_id
  limit 1;

  if v_owner = auth.uid() then
    update public.duel_rooms
    set status = 'canceled',
        finished_at = now()
    where id = p_room_id;
  end if;
end;
$$;

revoke all on function public.leave_duel_room(uuid) from public;
grant execute on function public.leave_duel_room(uuid) to authenticated;

create or replace function public.upsert_duel_progress(
  p_room_id uuid,
  p_typed_words integer,
  p_typed_chars integer,
  p_wpm integer,
  p_accuracy integer,
  p_is_finished boolean
)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  if not exists (
    select 1
    from public.duel_room_members m
    where m.room_id = p_room_id
      and m.user_id = auth.uid()
  ) then
    raise exception 'not in room';
  end if;

  insert into public.duel_progress (
    room_id,
    user_id,
    typed_words,
    typed_chars,
    wpm,
    accuracy,
    is_finished,
    finished_at,
    updated_at
  )
  values (
    p_room_id,
    auth.uid(),
    greatest(coalesce(p_typed_words, 0), 0),
    greatest(coalesce(p_typed_chars, 0), 0),
    greatest(coalesce(p_wpm, 0), 0),
    greatest(0, least(coalesce(p_accuracy, 0), 100)),
    coalesce(p_is_finished, false),
    case when coalesce(p_is_finished, false) then now() else null end,
    now()
  )
  on conflict (room_id, user_id) do update
    set typed_words = excluded.typed_words,
        typed_chars = excluded.typed_chars,
        wpm = excluded.wpm,
        accuracy = excluded.accuracy,
        is_finished = excluded.is_finished,
        finished_at = case
          when public.duel_progress.finished_at is not null then public.duel_progress.finished_at
          when excluded.is_finished then now()
          else null
        end,
        updated_at = now();
end;
$$;

revoke all on function public.upsert_duel_progress(uuid, integer, integer, integer, integer, boolean) from public;
grant execute on function public.upsert_duel_progress(uuid, integer, integer, integer, integer, boolean) to authenticated;

-- Realtime publication for duel mode tables
do $$
begin
  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'duel_rooms'
  ) then
    alter publication supabase_realtime add table public.duel_rooms;
  end if;

  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'duel_room_members'
  ) then
    alter publication supabase_realtime add table public.duel_room_members;
  end if;

  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'duel_room_invites'
  ) then
    alter publication supabase_realtime add table public.duel_room_invites;
  end if;

  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'duel_progress'
  ) then
    alter publication supabase_realtime add table public.duel_progress;
  end if;
exception
  when undefined_object then
    null;
end $$;
