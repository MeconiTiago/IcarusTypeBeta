-- Run this in Supabase SQL Editor

create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null unique,
  username text not null,
  avatar_url text,
  bio text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.profiles add column if not exists avatar_url text;
alter table public.profiles add column if not exists bio text;

alter table public.profiles enable row level security;

drop policy if exists "profiles_select_own" on public.profiles;
create policy "profiles_select_own"
on public.profiles
for select
to authenticated
using (auth.uid() = id);

drop policy if exists "profiles_insert_own" on public.profiles;
create policy "profiles_insert_own"
on public.profiles
for insert
to authenticated
with check (auth.uid() = id);

drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own"
on public.profiles
for update
to authenticated
using (auth.uid() = id)
with check (auth.uid() = id);

alter table public.profiles
  alter column username set not null;

do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'profiles_username_length_chk'
  ) then
    alter table public.profiles
      add constraint profiles_username_length_chk
      check (char_length(trim(username)) between 3 and 40);
  end if;

  if not exists (
    select 1 from pg_constraint
    where conname = 'profiles_bio_length_chk'
  ) then
    alter table public.profiles
      add constraint profiles_bio_length_chk
      check (bio is null or char_length(bio) <= 180);
  end if;
end $$;

-- Friend requests and social comparison
create table if not exists public.friend_requests (
  id bigint generated by default as identity primary key,
  requester_id uuid not null references auth.users(id) on delete cascade,
  recipient_id uuid not null references auth.users(id) on delete cascade,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'rejected')),
  created_at timestamptz not null default now(),
  responded_at timestamptz
);

create unique index if not exists idx_friend_requests_pair_unique
on public.friend_requests(requester_id, recipient_id);

create index if not exists idx_friend_requests_recipient_status
on public.friend_requests(recipient_id, status);

alter table public.friend_requests enable row level security;

drop policy if exists "friend_requests_select_related" on public.friend_requests;
create policy "friend_requests_select_related"
on public.friend_requests
for select
to authenticated
using (auth.uid() = requester_id or auth.uid() = recipient_id);

drop policy if exists "friend_requests_insert_self" on public.friend_requests;
create policy "friend_requests_insert_self"
on public.friend_requests
for insert
to authenticated
with check (auth.uid() = requester_id and requester_id <> recipient_id);

drop policy if exists "friend_requests_update_recipient" on public.friend_requests;
create policy "friend_requests_update_recipient"
on public.friend_requests
for update
to authenticated
using (auth.uid() = recipient_id and status = 'pending')
with check (auth.uid() = recipient_id and status in ('accepted', 'rejected'));

create or replace function public.create_friend_request_by_username(target_username text)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  me uuid := auth.uid();
  target uuid;
  existing_status text;
begin
  if me is null then
    raise exception 'not authenticated';
  end if;

  select id into target
  from public.profiles
  where lower(username) = lower(trim(target_username))
     or lower(email) = lower(trim(target_username))
  limit 1;

  if target is null then
    raise exception 'user not found';
  end if;

  if target = me then
    raise exception 'cannot add yourself';
  end if;

  select status into existing_status
  from public.friend_requests
  where (requester_id = me and recipient_id = target)
     or (requester_id = target and recipient_id = me)
  order by id desc
  limit 1;

  if existing_status = 'accepted' then
    return 'already friends';
  end if;

  if existing_status = 'pending' then
    update public.friend_requests
      set status = 'accepted',
          responded_at = now()
    where requester_id = target
      and recipient_id = me
      and status = 'pending';
    return 'request accepted';
  end if;

  insert into public.friend_requests (requester_id, recipient_id, status)
  values (me, target, 'pending')
  on conflict (requester_id, recipient_id) do update
    set status = 'pending',
        responded_at = null;

  return 'request sent';
end;
$$;

revoke all on function public.create_friend_request_by_username(text) from public;
grant execute on function public.create_friend_request_by_username(text) to authenticated;

-- Resolve login identifier (email or username) to email for auth flow
create or replace function public.get_login_email(login_identifier text)
returns text
language sql
security definer
set search_path = public
as $$
  select p.email
  from public.profiles p
  where lower(p.email) = lower(trim(login_identifier))
     or lower(p.username) = lower(trim(login_identifier))
  order by case when lower(p.email) = lower(trim(login_identifier)) then 0 else 1 end
  limit 1;
$$;

revoke all on function public.get_login_email(text) from public;
grant execute on function public.get_login_email(text) to anon, authenticated;

create or replace function public.respond_friend_request(req_id bigint, accept_request boolean)
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;

  update public.friend_requests
  set status = case when accept_request then 'accepted' else 'rejected' end,
      responded_at = now()
  where id = req_id
    and recipient_id = auth.uid()
    and status = 'pending';

  if not found then
    raise exception 'request not found';
  end if;
end;
$$;

revoke all on function public.respond_friend_request(bigint, boolean) from public;
grant execute on function public.respond_friend_request(bigint, boolean) to authenticated;

drop function if exists public.get_my_friend_requests();
create or replace function public.get_my_friend_requests()
returns table (
  request_id bigint,
  direction text,
  username text,
  avatar_url text,
  status text,
  created_at timestamptz
)
language sql
security definer
set search_path = public
as $$
  select
    fr.id as request_id,
    case when fr.recipient_id = auth.uid() then 'incoming' else 'outgoing' end as direction,
    coalesce(p.username, 'unknown') as username,
    p.avatar_url,
    fr.status,
    fr.created_at
  from public.friend_requests fr
  left join public.profiles p
    on p.id = case when fr.recipient_id = auth.uid() then fr.requester_id else fr.recipient_id end
  where fr.requester_id = auth.uid() or fr.recipient_id = auth.uid()
  order by fr.created_at desc;
$$;

revoke all on function public.get_my_friend_requests() from public;
grant execute on function public.get_my_friend_requests() to authenticated;

drop function if exists public.get_my_friends_with_stats();
create or replace function public.get_my_friends_with_stats()
returns table (
  friend_id uuid,
  username text,
  avatar_url text,
  games integer,
  best_wpm integer,
  avg_wpm integer,
  avg_acc integer
)
language sql
security definer
set search_path = public
as $$
  with friends as (
    select case when fr.requester_id = auth.uid() then fr.recipient_id else fr.requester_id end as friend_id
    from public.friend_requests fr
    where fr.status = 'accepted'
      and (fr.requester_id = auth.uid() or fr.recipient_id = auth.uid())
  )
  select
    f.friend_id,
    coalesce(p.username, 'unknown') as username,
    p.avatar_url,
    count(gr.id)::int as games,
    coalesce(max(gr.wpm), 0)::int as best_wpm,
    coalesce(round(avg(gr.wpm)), 0)::int as avg_wpm,
    coalesce(round(avg(gr.accuracy)), 0)::int as avg_acc
  from friends f
  left join public.profiles p on p.id = f.friend_id
  left join public.game_results gr on gr.user_id = f.friend_id
  group by f.friend_id, p.username, p.avatar_url
  order by avg_wpm desc, games desc, username asc;
$$;

revoke all on function public.get_my_friends_with_stats() from public;
grant execute on function public.get_my_friends_with_stats() to authenticated;

create or replace function public.set_profiles_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row
execute function public.set_profiles_updated_at();

-- Optional helper: create profile automatically on signup
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, email, username)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'username', split_part(new.email, '@', 1))
  )
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row
execute function public.handle_new_user();

-- Account deletion for logged users
create or replace function public.delete_my_account()
returns void
language plpgsql
security definer
set search_path = public, auth
as $$
begin
  if auth.uid() is null then
    raise exception 'not authenticated';
  end if;
  delete from auth.users where id = auth.uid();
end;
$$;

revoke all on function public.delete_my_account() from public;
grant execute on function public.delete_my_account() to authenticated;

-- Game results
create table if not exists public.game_results (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  song_title text,
  artist text,
  mode text not null default 'normal' check (mode in ('normal', 'cloze', 'rhythm')),
  wpm integer not null default 0,
  accuracy integer not null default 0,
  words_correct integer not null default 0,
  words_wrong integer not null default 0,
  total_chars integer not null default 0,
  incorrect_chars integer not null default 0,
  extra_chars integer not null default 0,
  duration_seconds integer not null default 0,
  created_at timestamptz not null default now()
);

create index if not exists idx_game_results_user_created_at
on public.game_results(user_id, created_at desc);

alter table public.game_results enable row level security;

drop policy if exists "game_results_select_own" on public.game_results;
create policy "game_results_select_own"
on public.game_results
for select
to authenticated
using (auth.uid() = user_id);

drop policy if exists "game_results_insert_own" on public.game_results;
create policy "game_results_insert_own"
on public.game_results
for insert
to authenticated
with check (auth.uid() = user_id);

drop policy if exists "game_results_delete_own" on public.game_results;
create policy "game_results_delete_own"
on public.game_results
for delete
to authenticated
using (auth.uid() = user_id);

do $$
begin
  if not exists (
    select 1 from pg_constraint
    where conname = 'game_results_accuracy_chk'
  ) then
    alter table public.game_results
      add constraint game_results_accuracy_chk
      check (accuracy between 0 and 100);
  end if;

  if not exists (
    select 1 from pg_constraint
    where conname = 'game_results_non_negative_chk'
  ) then
    alter table public.game_results
      add constraint game_results_non_negative_chk
      check (
        wpm >= 0 and
        words_correct >= 0 and
        words_wrong >= 0 and
        total_chars >= 0 and
        incorrect_chars >= 0 and
        extra_chars >= 0 and
        duration_seconds >= 0
      );
  end if;
end $$;

-- Favorites playlist
create table if not exists public.user_favorites (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  song_title text not null,
  artist text not null,
  created_at timestamptz not null default now(),
  unique(user_id, song_title, artist)
);

create index if not exists idx_user_favorites_user_created
on public.user_favorites(user_id, created_at desc);

alter table public.user_favorites enable row level security;

drop policy if exists "user_favorites_select_own" on public.user_favorites;
create policy "user_favorites_select_own"
on public.user_favorites
for select
to authenticated
using (auth.uid() = user_id);

drop policy if exists "user_favorites_insert_own" on public.user_favorites;
create policy "user_favorites_insert_own"
on public.user_favorites
for insert
to authenticated
with check (auth.uid() = user_id);

drop policy if exists "user_favorites_delete_own" on public.user_favorites;
create policy "user_favorites_delete_own"
on public.user_favorites
for delete
to authenticated
using (auth.uid() = user_id);

-- Avatar storage bucket (public read, owner write/delete)
insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

drop policy if exists "avatars_public_read" on storage.objects;
create policy "avatars_public_read"
on storage.objects
for select
to public
using (bucket_id = 'avatars');

drop policy if exists "avatars_insert_own" on storage.objects;
create policy "avatars_insert_own"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
);

drop policy if exists "avatars_update_own" on storage.objects;
create policy "avatars_update_own"
on storage.objects
for update
to authenticated
using (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
)
with check (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
);

drop policy if exists "avatars_delete_own" on storage.objects;
create policy "avatars_delete_own"
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'avatars'
  and auth.uid()::text = (storage.foldername(name))[1]
);
